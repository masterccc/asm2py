#!/usr/bin/python3

import os, sys, re



def gen_instruction(txt, tab=0, nl=0):
	return tab * "\t" + txt + "\n" + nl * "\n"

def gen_header(filename, funcname):
	
	header = gen_instruction("#!/usr/bin/python3\n")
	header += gen_instruction("# Generated by Asm2py")
	header += gen_instruction("# Binary : " + filename)
	header += gen_instruction("# Function : " + funcname, 0, 2)

	header += gen_instruction("#Create Stack")
	header += gen_instruction("stack = list()",0,1)

	header += gen_instruction("#Create registers")
	header += gen_instruction("eax = ebx = ecx = edx = 0",0,1)

	header += gen_instruction("# .text section")
	return header
#
def create_script(filename, funcname):
	output_name = filename + "::" + funcname + ".py"
	file = open(output_name, "w")
	file.write(gen_header(filename,funcname))
	return file

def get_func_list(raw_asm):
	re_find_func = re.compile(RE_FUNC)
	func = re_find_func.findall(raw_asm)
	func_list = []
	i = 1
	for func_found in func :
		func_name =	func_found.replace('<','').replace('>','')
		func_list.append(func_name)
		print(i, ":", func_name)
		i += 1
	return func_list

def choose_func(funcs):

	good_choice = False
	maxf = len(funcs)
	input_str = "Function to pythonize ? [1-" + str(maxf) + "]"
	while(not good_choice):
		try:
			choice = int(input(input_str))
			if(choice > 0 and choice <= maxf):
				good_choice = True
		except ValueError:
			print("Bad value")
	return funcs[choice-1]
	
def get_raw_func(raw_asm,func_name):

	raw = ""
	regex_func = r'<'+func_name+'([\+0x[a-f0-9]*)?>'
	regex_find = re.compile(regex_func)
	
	for line in raw_asm.split("\n"):
		if(regex_find.search(line)):
			raw += line + "\n"
	return raw


def analyze(raw_func, ofile):


	raw_func = bulk_transform(raw_func)

	for line in raw_func.split("\n"):
		opcodes = " ".join(line.split()[2:])
		ofile.write(opcodes + '\n')

def bulk_transform(raw_func):


	raw_func = re.sub(r"( |\t){2,}"," ", raw_func)
	#raw_func = re.sub(" +"," ", raw_func)
	
	bulk_dict = [

		# General 
		{"from" : r"mov ([a-z]{3}),([0-9a-z]*)", "to":r"\1 = \2"},
		
		#Bitwise
		{"from" : r"shr ([a-z]{3}),([0-9a-z]*)", "to":r"\1 = \1 >> \2"},
		{"from" : r"shl ([a-z]{3}),([0-9a-z]*)", "to":r"\1 = \1 << \2"},
		{"from" : r"xor ([a-z]{3}),([0-9a-z]*)", "to":r"\1 ^= \2"},

		#Basic operations
		{"from" : r"add ([a-z]{3}),([0-9a-z]*)", "to":r"\1 += \2"},
		{"from" : r"sub ([a-z]{3}),([0-9a-z]*)", "to":r"\1 -= \2"},
		
		# Stack
		{"from" : r"push ([a-z]{3})", "to": r"stack.append(\1)"},
		{"from" : r"pop ([a-z]{3})", "to": r"\1 = stack.pop()"}
	#	{"from": "a", "to": "d"}
	]

	for item in bulk_dict:
		raw_func = re.sub(item["from"], item["to"], raw_func)

	return raw_func

DUMP_CMD="objdump -d -M intel --no-show-raw-insn --prefix-addresses"

RE_FUNC = r'<[a-zA-Z_]*>'


if(len(sys.argv) < 2):
	print("usage ./", sys.argv[0], ' binary')
	sys.exit(1)

raw_asm = os.popen(DUMP_CMD + " " + sys.argv[1])
raw_asm = raw_asm.read()

func_name_analyze = choose_func(get_func_list(raw_asm))
print("Function :", func_name_analyze)

raw_func = get_raw_func(raw_asm,func_name_analyze)
#print(raw_func)

output_file = create_script(sys.argv[1], func_name_analyze)

analyze(raw_func, output_file)

output_file.close()


# convertir write en printf

#dump strings dans un tableau data= { [offset] = "string" }